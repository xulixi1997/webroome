<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P ç»å¯†ç»ˆç«¯ | 1GB å¤§æ–‡ä»¶ç‰ˆ</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary: #8b5cf6;
            --bg: #000000;
            --card-bg: rgba(20, 20, 20, 0.9);
            --text-main: #e5e5e5;
            --danger: #ef4444;
            --success: #10b981;
        }
        * { box-sizing: border-box; outline: none; }
        body {
            font-family: 'Courier New', monospace; background: var(--bg); color: var(--text-main);
            margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        .grid-bg {
            position: absolute; width: 200%; height: 200%;
            background-image: linear-gradient(rgba(50, 50, 50, 0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(50, 50, 50, 0.3) 1px, transparent 1px);
            background-size: 40px 40px; transform: perspective(500px) rotateX(60deg); animation: moveGrid 20s linear infinite; z-index: -1; opacity: 0.5;
        }
        @keyframes moveGrid { from { transform: perspective(500px) rotateX(60deg) translateY(0); } to { transform: perspective(500px) rotateX(60deg) translateY(40px); } }

        .card {
            background: var(--card-bg); border: 1px solid #333; padding: 40px; border-radius: 4px; width: 420px;
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.1); display: none; text-align: center;
        }
        .card.active { display: block; animation: fadeIn 0.5s; }
        .btn {
            background: var(--primary); color: white; border: none; padding: 15px; border-radius: 2px; cursor: pointer;
            font-weight: bold; width: 100%; text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
        }
        .btn:hover { background: #7c3aed; box-shadow: 0 0 15px var(--primary); }
        .btn:disabled { background: #333; cursor: not-allowed; }
        input[type="text"] {
            width: 100%; background: #0a0a0a; border: 1px solid #333; color: var(--primary); padding: 15px; margin-bottom: 20px; font-size: 16px; text-align: center;
        }
        .key-display {
            background: #111; border: 1px dashed #444; padding: 20px; margin: 20px 0; color: var(--success); font-size: 18px; word-break: break-all; cursor: pointer; position: relative;
        }
        .key-display:hover::after {
            content: "ç‚¹å‡»å¤åˆ¶é‚€è¯·å‡½"; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; color: white; font-size: 14px;
        }

        #chat-container { width: 95%; max-width: 1000px; height: 95vh; display: none; flex-direction: column; background: #0a0a0a; border: 1px solid #333; position: relative; }
        header { padding: 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; background: #0f0f0f; }
        .enc-badge { color: var(--success); font-size: 12px; border: 1px solid var(--success); padding: 2px 6px; border-radius: 2px; }
        #msg-list { flex: 1; overflow-y: auto; padding: 20px; }
        .msg-row { margin-bottom: 15px; display: flex; flex-direction: column; }
        .msg-row.me { align-items: flex-end; }
        .bubble { max-width: 70%; padding: 10px 15px; background: #1a1a1a; border: 1px solid #333; color: #ddd; word-wrap: break-word; }
        .me .bubble { background: #1e1b4b; border-color: var(--primary); color: #fff; }
        footer { padding: 15px; border-top: 1px solid #333; display: flex; gap: 10px; background: #0f0f0f; }
        .icon-btn { width: 50px; background: #222; border: 1px solid #333; color: #fff; cursor: pointer; font-size: 20px; }
        #drag-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100;
            display: none; flex-direction: column; justify-content: center; align-items: center; border: 2px dashed var(--primary);
        }
        #drag-overlay.active { display: flex; }
        #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 999; }
        .toast-msg { background: #222; border: 1px solid #444; color: #fff; padding: 10px 20px; margin-bottom: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: fade 3s forwards; }
        .progress-bar { height: 2px; background: #333; width: 100%; margin-top: 8px; }
        .progress-fill { height: 100%; background: var(--success); width: 0%; transition: width 0.2s; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        @keyframes fade { 0% { opacity: 0; margin-top: -10px; } 10% { opacity: 1; margin-top: 0; } 90% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    <div id="toast"></div>

    <div id="card-login" class="card active">
        <h2 style="color: var(--primary);">AES-256 1GB ç»ˆç«¯</h2>
        <input type="text" id="nick-in" placeholder="ä»£å· (Nickname)" maxlength="10">
        <input type="text" id="room-in" placeholder="é¢‘é“ (Room ID)">
        <button class="btn" onclick="startApp()">å»ºç«‹è¿æ¥</button>
    </div>

    <div id="card-host" class="card">
        <h3>é¢‘é“å·²å»ºç«‹</h3>
        <div class="key-display" id="host-key-display" onclick="copyInviteInfo()"></div>
        <div style="font-size: 12px; color: var(--danger); margin-bottom: 20px;">âš ï¸ é”™è¯¯è§£å¯† 10 æ¬¡è§¦å‘ç†”æ–­</div>
        <button class="btn" onclick="enterChat('host')">è¿›å…¥ç»ˆç«¯</button>
    </div>

    <div id="card-guest" class="card">
        <h3>èº«ä»½éªŒè¯</h3>
        <input type="text" id="auth-in" placeholder="è¾“å…¥å¯†é’¥" style="letter-spacing: 2px; font-weight: bold;">
        <button class="btn" onclick="submitAuth()">è§£å¯†å¹¶è¿›å…¥</button>
    </div>

    <div id="chat-container">
        <div id="drag-overlay"><div style="font-size: 40px;">ğŸ“‚</div><div>é‡Šæ”¾ä»¥åŠ å¯†å‘é€</div></div>
        <header>
            <div><span style="color: #888;">CH:</span> <span id="head-room" style="font-weight: bold;">...</span> <span class="enc-badge">AES-GCM</span></div>
            <div id="head-nick">...</div>
        </header>
        <div id="msg-list"></div>
        <footer>
            <button class="icon-btn" onclick="document.getElementById('file-in').click()">+</button>
            <input type="file" id="file-in" style="display:none" onchange="processFile(this.files[0])">
            <input type="text" id="msg-in" placeholder="åŠ å¯†æ¶ˆæ¯..." style="margin:0;" onkeypress="if(event.key==='Enter') sendMsg()">
            <button class="btn" style="width: auto; padding: 0 30px; margin-left: 10px;" onclick="sendMsg()">SEND</button>
        </footer>
    </div>

    <script>
        // --- é«˜æ€§èƒ½åŠ å¯†æ¨¡å— ---
        const CryptoManager = {
            key: null,
            
            async deriveKey(password, salt) {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), {name: "PBKDF2"}, false, ["deriveKey"]);
                this.key = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: enc.encode(salt), iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );
            },

            // æ–‡æœ¬/å¯¹è±¡åŠ å¯† (JSON -> String -> Encrypt)
            async encryptJson(dataObj) {
                const enc = new TextEncoder();
                const encoded = enc.encode(JSON.stringify(dataObj));
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, this.key, encoded);
                return { iv: Array.from(iv), ct: Array.from(new Uint8Array(ciphertext)), mode: 'json' };
            },

            // äºŒè¿›åˆ¶æµåŠ å¯† (Raw Buffer -> Encrypt -> Raw Buffer) - ä¸“é—¨ç”¨äºå¤§æ–‡ä»¶
            async encryptBuffer(buffer) {
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, this.key, buffer);
                return { iv: Array.from(iv), ct: ciphertext, mode: 'bin' }; // ct ä¿æŒä¸º ArrayBuffer
            },

            // é€šç”¨è§£å¯†
            async decrypt(pkg) {
                if (!this.key) throw new Error("No Key");
                const iv = new Uint8Array(pkg.iv);
                
                // åŒºåˆ† JSON æ¨¡å¼å’Œ Binary æ¨¡å¼
                if (pkg.mode === 'bin') {
                    // äºŒè¿›åˆ¶è§£å¯†ç›´æ¥è¿”å› ArrayBuffer
                    return await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, this.key, pkg.ct);
                } else {
                    // JSON è§£å¯†
                    const data = new Uint8Array(pkg.ct);
                    const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, this.key, data);
                    return JSON.parse(new TextDecoder().decode(decrypted));
                }
            }
        };

        const MAX_FAILURES = 10;
        let peer, myRole, myNick, roomId, roomPwd;
        let failureCount = 0;
        let connMap = new Map();
        let hostConn = null;
        let incomingFiles = {};

        function startApp() {
            const nick = document.getElementById('nick-in').value.trim();
            const room = document.getElementById('room-in').value.trim();
            if (!nick || !room) return showToast('è¯·è¾“å…¥å®Œæ•´ä¿¡æ¯', 'err');
            myNick = nick; roomId = room;
            
            const btn = document.querySelector('#card-login .btn');
            btn.disabled = true; btn.innerText = "æ­£åœ¨æ¡æ‰‹...";
            
            const fullId = 'aes-1gb-' + room; // å‡çº§åè®®ID
            const tempPeer = new Peer(fullId);

            tempPeer.on('open', () => { peer = tempPeer; initHost(); });
            tempPeer.on('error', (err) => {
                if (err.type === 'unavailable-id') { tempPeer.destroy(); initGuest(fullId); }
                else { showToast('é”™è¯¯: ' + err.type, 'err'); btn.disabled = false; }
            });
        }

        async function initHost() {
            myRole = 'host';
            roomPwd = generateStrongPwd();
            await CryptoManager.deriveKey(roomPwd, roomId);
            document.getElementById('host-key-display').innerText = roomPwd;
            switchCard('card-host');

            peer.on('connection', conn => {
                conn.on('data', async (encryptedData) => {
                    try {
                        let data;
                        // åˆ¤æ–­æ˜¯äºŒè¿›åˆ¶åŒ…è¿˜æ˜¯JSONåŒ…
                        if (encryptedData.mode === 'bin') {
                            // æˆ¿ä¸»ä½œä¸ºä¸­è½¬ç«™ï¼Œå¦‚æœæ˜¯äºŒè¿›åˆ¶æµï¼Œé€šå¸¸ç›´æ¥è§£å¯†è½¬å‘å¤ªè€—è´¹ï¼Œ
                            // ä½†ä¸ºäº†ä¸¥è°¨éªŒè¯å¯†ç ï¼Œæˆ‘ä»¬è§£å¯†å¤´å‡ ä¸ªå­—èŠ‚? 
                            // ç®€åŒ–é€»è¾‘ï¼šæ‰€æœ‰åŒ…éƒ½å¿…é¡»èƒ½è§£å¯†æ‰ç®—åˆæ³•
                            // æ³¨æ„ï¼šæˆ¿ä¸»è½¬å‘å¤§æ–‡ä»¶åˆ‡ç‰‡æ—¶ï¼Œè§£å¯†å†åŠ å¯†å¼€é”€å·¨å¤§ã€‚
                            // ä½†ä¸ºäº†â€œå…¨å†…å®¹åŠ å¯†â€ï¼Œè¿™é‡Œæ¼”ç¤ºå®Œå…¨è§£å¯†ã€‚
                            // å®é™…ç”Ÿäº§ä¸­ï¼Œå¤§æ–‡ä»¶ä¼ è¾“å¯ä½¿ç”¨â€œå…±äº«ä¼šè¯å¯†é’¥â€æ¥é€ä¼ ã€‚
                            const buffer = await CryptoManager.decrypt(encryptedData);
                            // è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶åˆ‡ç‰‡ï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒåŒ…å›å¤´ï¼Œæˆ–è€…å¤„ç†å®ƒ
                            // è¿™é‡Œæœ‰ä¸€ä¸ªç‰¹æ®Šå¤„ç†ï¼šPeerJS å‘é€ ArrayBuffer æ—¶ï¼Œæˆ‘ä»¬æ— æ³•é™„å¸¦ metadataã€‚
                            // æ‰€ä»¥ V7.1 æ–¹æ¡ˆï¼šæ–‡ä»¶åˆ‡ç‰‡ä¹Ÿé€šè¿‡å¸¦ payload çš„å¯¹è±¡å‘é€ï¼Œä½† payload æ˜¯åŠ å¯†åçš„ Buffer
                            // è§ processFile é€»è¾‘ã€‚
                        } else {
                            data = await CryptoManager.decrypt(encryptedData);
                        }

                        // å¦‚æœèµ°åˆ°äº†è¿™é‡Œï¼Œè¯´æ˜ data è§£å¯†æˆåŠŸ (æ˜¯ JSON) æˆ–è€…ä¸Šä¸€æ­¥äºŒè¿›åˆ¶è§£å¯†æ²¡æŠ¥é”™
                        // V7.1 ä¸­ï¼ŒFILE_CHUNK_BIN æ˜¯ä¸€ç§æ··åˆä½“ï¼šå¤–å±‚ JSON (å« IV)ï¼Œå†…å±‚æ˜¯ ArrayBuffer
                        // æˆ‘ä»¬åœ¨ decrypt ç»Ÿä¸€å¤„ç†äº†ã€‚
                        
                        if (data.type === 'HELLO') {
                            connMap.set(conn.peer, conn);
                            sendTo(conn, { type: 'WELCOME', content: 'åŠ å¯†é€šé“å·²å»ºç«‹' });
                            showToast('æ–°èŠ‚ç‚¹å·²æ¥å…¥', 'ok');
                        } else {
                            handleDecryptedData(data, conn);
                        }
                    } catch (e) {
                        failureCount++;
                        if (failureCount >= MAX_FAILURES) destroyRoom();
                    }
                });
                conn.on('close', () => connMap.delete(conn.peer));
            });
        }

        function destroyRoom() {
            peer.destroy(); alert("ç†”æ–­æœºåˆ¶è§¦å‘ï¼Œæˆ¿é—´é”€æ¯"); location.reload();
        }

        function initGuest(hostId) {
            myRole = 'guest';
            peer = new Peer();
            peer.on('open', () => {
                hostConn = peer.connect(hostId);
                hostConn.on('open', () => switchCard('card-guest'));
                hostConn.on('data', async (pkg) => {
                    try {
                        // è®¿å®¢æ”¶åˆ°æ•°æ®ï¼Œå¯èƒ½æ˜¯ JSON åŒ…ï¼Œä¹Ÿå¯èƒ½æ˜¯åŒ…å«äºŒè¿›åˆ¶çš„åŒ…
                        // CryptoManager.decrypt è‡ªåŠ¨å¤„ç† mode='bin'
                        // ä½†å¦‚æœæ˜¯ FILE_CHUNK_BINï¼Œå¤–å±‚æ˜¯ JSONï¼Œå†…å±‚ payload æ˜¯åŠ å¯†çš„
                        
                        // ç»Ÿä¸€è§£å¯†å…¥å£
                        const data = await CryptoManager.decrypt(pkg);
                        handleDecryptedData(data);
                    } catch (e) { console.error(e); }
                });
            });
        }

        async function submitAuth() {
            const pwd = document.getElementById('auth-in').value.trim();
            if (!pwd) return;
            await CryptoManager.deriveKey(pwd, roomId);
            document.querySelector('#card-guest .btn').innerText = "éªŒè¯ä¸­...";
            await sendTo(hostConn, { type: 'HELLO', nick: myNick });
        }

        function handleDecryptedData(data, senderConn) {
            if (data.type === 'WELCOME') { showToast(data.content, 'ok'); enterChat('guest'); }
            else if (data.type === 'MSG') renderMsg(data, false);
            else if (data.type === 'FILE_META') handleFileStart(data);
            else if (data.type === 'FILE_CHUNK_BIN') handleFileChunk(data);

            if (myRole === 'host') {
                // è½¬å‘ï¼šä¸ºäº†æ€§èƒ½ï¼Œç†æƒ³æƒ…å†µæ˜¯ç›´æ¥è½¬å‘ raw encrypted packageã€‚
                // ä½†å› ä¸ºæˆ‘ä»¬å·²ç»è§£å¯†äº†ï¼Œå¦‚æœä¸é‡æ–°åŠ å¯†ï¼Œå°±å‘ä¸å‡ºå»äº†ã€‚
                // ä¸ºäº†æ¼”ç¤ºæ•ˆæœï¼Œè¿™é‡Œé‡æ–°åŠ å¯†å‘é€ï¼ˆæ¶ˆè€— CPUï¼‰ã€‚
                connMap.forEach(c => {
                    if (c !== senderConn && c.open) sendTo(c, data);
                });
            }
        }

        // --- æ ¸å¿ƒï¼šæ™ºèƒ½å‘é€ ---
        async function sendTo(conn, data) {
            // å¦‚æœæ•°æ®åŒ…å«äºŒè¿›åˆ¶ payload (æ–‡ä»¶åˆ‡ç‰‡)ï¼Œä½¿ç”¨ç‰¹æ®ŠåŠ å¯†è·¯å¾„
            if (data.type === 'FILE_CHUNK_BIN') {
                // 1. åŠ å¯†äºŒè¿›åˆ¶ payload
                const encryptedBin = await CryptoManager.encryptBuffer(data.payload);
                
                // 2. å°†åŠ å¯†åçš„äºŒè¿›åˆ¶æ•°æ®åŒ…è£…åœ¨æ™®é€š JSON ä¿¡ä»¤ä¸­å‘é€
                // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸åŠ å¯†å¤–å±‚ JSON äº†å—ï¼Ÿ
                // ä¸ï¼Œä¸ºäº†å®‰å…¨ï¼Œæˆ‘ä»¬æŠŠ IV å’Œ CT æ”¾åœ¨å¤–å±‚ï¼Œä½œä¸ºæ™®é€š JSON å‘é€ï¼Œ
                // æ¥æ”¶ç«¯è§£å¯† JSON åå¾—åˆ°çš„æ˜¯ï¼š{ type: 'FILE_CHUNK_BIN', payload: <ArrayBuffer> }
                
                // ç­‰ç­‰ï¼ŒPeerJS ä¼ è¾“ ArrayBuffer æœ€é«˜æ•ˆã€‚
                // æ–¹æ¡ˆï¼šå°†æ•´ä¸ªåŒ…åŠ å¯†æˆ JSON å­—ç¬¦ä¸²è™½ç„¶æ…¢ï¼Œä½†æœ€å…¼å®¹ã€‚
                // ä¼˜åŒ–æ–¹æ¡ˆï¼šæˆ‘ä»¬åªåŠ å¯† payloadï¼Œå¤–å±‚ä¿æŒ JSON æ˜æ–‡ï¼ˆä½†åŒ…å« fileIdï¼‰ã€‚
                // è¿™æ ·æ¥æ”¶ç«¯çŸ¥é“æ˜¯å“ªä¸ªæ–‡ä»¶ï¼Œä¸” payload æ˜¯ AES åŠ å¯†çš„ä¹±ç ã€‚
                // è¿™æš´éœ²äº† metadata (fileId)ï¼Œä½†å†…å®¹æ˜¯å®‰å…¨çš„ã€‚è¿™æ˜¯æ€§èƒ½å¦¥åçš„æœ€ä½³ç‚¹ã€‚
                
                conn.send({
                    type: 'FILE_CHUNK_BIN',
                    fileId: data.fileId,
                    iv: encryptedBin.iv,
                    ct: encryptedBin.ct, // è¿™æ˜¯ä¸€ä¸ª ArrayBuffer
                    mode: 'bin_chunk'    // æ ‡è®°è¿™æ˜¯ç‰¹æ®ŠåŒ…
                });
            } else {
                // æ™®é€š JSON æ¶ˆæ¯ï¼šå…¨åŠ å¯†
                const encrypted = await CryptoManager.encryptJson(data);
                conn.send(encrypted);
            }
        }
        
        // æ¥æ”¶ç«¯ç‰¹æ®Šå¤„ç†é€»è¾‘ä¿®æ­£
        // æˆ‘ä»¬ä¿®æ”¹ CryptoManager.decrypt å—ï¼Ÿä¸ï¼Œæˆ‘ä»¬åœ¨ on('data') é‡Œå¤„ç†ã€‚
        // ä¿®æ”¹ on('data') é€»è¾‘ï¼š
        /* if (pkg.mode === 'bin_chunk') {
               // è¿™æ˜¯ä¸€ä¸ªåŠæ˜æ–‡åŒ…ï¼šfileId æ˜æ–‡ï¼Œå†…å®¹åŠ å¯†
               // æ‰‹åŠ¨è§£å¯†å†…å®¹
               const iv = new Uint8Array(pkg.iv);
               const plainBuffer = await window.crypto.subtle.decrypt(
                   { name: "AES-GCM", iv: iv }, CryptoManager.key, pkg.ct
               );
               handleDecryptedData({ type: 'FILE_CHUNK_BIN', fileId: pkg.fileId, payload: plainBuffer });
               return;
           }
        */
        
        // é‡æ–°ä¿®è¡¥ initHost å’Œ initGuest çš„ on('data')
        // è¯·çœ‹ä¸‹é¢çš„ overwrite

    </script>
    
    <script>
        // è¦†ç›– Host ç›‘å¬
        function patchHostListener(conn) {
            conn.on('data', async (pkg) => {
                try {
                    let finalData;
                    if (pkg.mode === 'bin_chunk') {
                        // ä¼˜åŒ–è·¯å¾„ï¼šå¤§æ–‡ä»¶åˆ‡ç‰‡
                        const iv = new Uint8Array(pkg.iv);
                        const plainBuffer = await window.crypto.subtle.decrypt(
                            { name: "AES-GCM", iv: iv }, CryptoManager.key, pkg.ct
                        );
                        finalData = { type: 'FILE_CHUNK_BIN', fileId: pkg.fileId, payload: plainBuffer };
                    } else {
                        // æ™®é€šè·¯å¾„ï¼šå…¨åŠ å¯† JSON
                        finalData = await CryptoManager.decrypt(pkg);
                    }

                    if (finalData.type === 'HELLO') {
                        connMap.set(conn.peer, conn);
                        sendTo(conn, { type: 'WELCOME', content: 'åŠ å¯†é€šé“å·²å»ºç«‹' });
                        showToast('æ–°èŠ‚ç‚¹å·²æ¥å…¥', 'ok');
                    } else {
                        handleDecryptedData(finalData, conn);
                    }
                } catch (e) {
                    failureCount++;
                    if (failureCount >= MAX_FAILURES) destroyRoom();
                }
            });
        }
        
        // è¦†ç›– Guest ç›‘å¬
        function patchGuestListener() {
            hostConn.on('data', async (pkg) => {
                try {
                    let finalData;
                    if (pkg.mode === 'bin_chunk') {
                        const iv = new Uint8Array(pkg.iv);
                        const plainBuffer = await window.crypto.subtle.decrypt(
                            { name: "AES-GCM", iv: iv }, CryptoManager.key, pkg.ct
                        );
                        finalData = { type: 'FILE_CHUNK_BIN', fileId: pkg.fileId, payload: plainBuffer };
                    } else {
                        finalData = await CryptoManager.decrypt(pkg);
                    }
                    handleDecryptedData(finalData);
                } catch (e) { console.error(e); }
            });
        }

        // é‡æ–°ç»‘å®š peer connection é€»è¾‘
        const originalInitHost = initHost;
        initHost = async function() {
            myRole = 'host';
            roomPwd = generateStrongPwd();
            await CryptoManager.deriveKey(roomPwd, roomId);
            document.getElementById('host-key-display').innerText = roomPwd;
            switchCard('card-host');

            peer.on('connection', conn => {
                patchHostListener(conn); // ä½¿ç”¨è¡¥ä¸ç›‘å¬å™¨
                conn.on('close', () => connMap.delete(conn.peer));
            });
        }

        const originalInitGuest = initGuest;
        initGuest = function(hostId) {
            myRole = 'guest';
            peer = new Peer();
            peer.on('open', () => {
                hostConn = peer.connect(hostId);
                hostConn.on('open', () => switchCard('card-guest'));
                patchGuestListener(); // ä½¿ç”¨è¡¥ä¸ç›‘å¬å™¨
            });
        }
    </script>

    <script>
        // --- ä¸šåŠ¡é€»è¾‘ï¼šå‘é€ä¸æ–‡ä»¶ ---
        async function sendMsg() {
            const input = document.getElementById('msg-in');
            const txt = input.value.trim();
            if (!txt) return;
            const pkg = { type: 'MSG', content: txt, nick: myNick };
            renderMsg(pkg, true);
            
            if (myRole === 'host') connMap.forEach(c => sendTo(c, pkg));
            else sendTo(hostConn, pkg);
            input.value = '';
        }

        async function processFile(file) {
            if (!file) return;
            // æ¢å¤é™åˆ¶åˆ° 1GB
            if (file.size > 1024 * 1024 * 1024) return showToast('æ–‡ä»¶è¶…é™ (>1GB)', 'err');

            const fileId = Date.now().toString();
            const meta = { type: 'FILE_META', fileId, name: file.name, size: file.size, type: file.type, nick: myNick };
            renderFileMsg(fileId, file.name, true, null);
            
            if (myRole === 'host') connMap.forEach(c => sendTo(c, meta));
            else sendTo(hostConn, meta);

            const reader = new FileReader();
            let offset = 0;
            const CHUNK = 16 * 1024; // 16KB åˆ‡ç‰‡ä»¥ä¿è¯åŠ å¯†æ€§èƒ½

            const readNext = () => {
                const slice = file.slice(offset, offset + CHUNK);
                reader.readAsArrayBuffer(slice);
            };

            reader.onload = async (e) => {
                // æ„é€ äºŒè¿›åˆ¶åˆ‡ç‰‡åŒ…
                const chunkPkg = { 
                    type: 'FILE_CHUNK_BIN', 
                    fileId: fileId, 
                    payload: e.target.result // ArrayBuffer
                };
                
                if (myRole === 'host') {
                     // ç®€å•ä¸²è¡Œå‘é€
                     for (let c of connMap.values()) await sendTo(c, chunkPkg);
                } else {
                    await sendTo(hostConn, chunkPkg);
                }

                offset += e.target.result.byteLength;
                updateProgress(fileId, offset, file.size);
                if (offset < file.size) readNext();
            };
            readNext();
            document.getElementById('file-in').value = '';
        }

        function handleFileChunk(data) {
            const ctx = incomingFiles[data.fileId];
            if (!ctx) return;
            
            // data.payload æ˜¯å·²ç»è§£å¯†çš„ ArrayBuffer
            ctx.buffer.push(data.payload); 
            ctx.received += data.payload.byteLength;
            updateProgress(data.fileId, ctx.received, ctx.total);

            if (ctx.received >= ctx.total) {
                const blob = new Blob(ctx.buffer, { type: ctx.meta.type });
                finishFile(data.fileId, blob, ctx.meta.name);
                // é‡Šæ”¾å†…å­˜
                ctx.buffer = null; 
                delete incomingFiles[data.fileId];
            }
        }
        
        function handleFileStart(data) {
            incomingFiles[data.fileId] = { buffer: [], received: 0, total: data.size, meta: data };
            renderFileMsg(data.fileId, data.name, false, data.nick);
        }

        // --- UI Utils ---
        function enterChat(role) {
            document.querySelectorAll('.card').forEach(e => e.classList.remove('active'));
            document.getElementById('chat-container').style.display = 'flex';
            document.getElementById('head-room').innerText = roomId;
            document.getElementById('head-nick').innerText = myNick;
            setupDrag();
        }
        function switchCard(id) { document.querySelectorAll('.card').forEach(e => e.classList.remove('active')); document.getElementById(id).classList.add('active'); }
        function renderMsg(data, isMe) {
            const list = document.getElementById('msg-list');
            const div = document.createElement('div');
            div.className = `msg-row ${isMe ? 'me' : 'other'}`;
            div.innerHTML = `${!isMe ? `<div style="font-size:12px; color:#666; margin-bottom:4px;">${data.nick}</div>` : ''}<div class="bubble">${escape(data.content)}</div>`;
            list.appendChild(div); list.scrollTop = list.scrollHeight;
        }
        function renderFileMsg(id, name, isMe, nick) {
            const list = document.getElementById('msg-list');
            const div = document.createElement('div');
            div.className = `msg-row ${isMe ? 'me' : 'other'}`;
            div.innerHTML = `${!isMe && nick ? `<div style="font-size:12px; color:#666; margin-bottom:4px;">${nick}</div>` : ''}<div class="bubble" id="b-${id}"><div>${isMe?'ğŸ“¤':'ğŸ“¥'} åŠ å¯†æ–‡ä»¶: ${name}</div><div class="progress-bar"><div class="progress-fill" id="p-${id}"></div></div></div>`;
            list.appendChild(div); list.scrollTop = list.scrollHeight;
        }
        function updateProgress(id, cur, total) { const el = document.getElementById(`p-${id}`); if(el) el.style.width = (cur/total*100) + '%'; }
        function finishFile(id, blob, name) { const url = URL.createObjectURL(blob); const el = document.getElementById(`b-${id}`); if(el) el.innerHTML = `<div style="color:var(--success)">âœ… è§£å¯†å®Œæˆ</div><a href="${url}" download="${name}" style="color:#fff">ä¿å­˜æ–‡ä»¶</a>`; }
        function generateStrongPwd() { const c = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$'; let r=''; for(let i=0;i<12;i++) r+=c.charAt(Math.floor(Math.random()*c.length)); return r; }
        function copyInviteInfo() { navigator.clipboard.writeText(`[P2P åŠ å¯†é¢‘é“]\næˆ¿å·: ${roomId}\nå¯†é’¥: ${roomPwd}`); showToast('é‚€è¯·å‡½å·²å¤åˆ¶', 'ok'); }
        function showToast(msg, type) { const t = document.getElementById('toast'); const d = document.createElement('div'); d.className = 'toast-msg'; d.style.borderLeftColor = type === 'ok' ? 'var(--success)' : 'var(--danger)'; d.innerText = msg; t.appendChild(d); setTimeout(() => d.remove(), 3000); }
        function setupDrag() { const b = document.getElementById('chat-container'); const o = document.getElementById('drag-overlay'); b.addEventListener('dragover', e => { e.preventDefault(); o.classList.add('active'); }); o.addEventListener('dragleave', e => { e.preventDefault(); o.classList.remove('active'); }); o.addEventListener('drop', e => { e.preventDefault(); o.classList.remove('active'); if(e.dataTransfer.files[0]) processFile(e.dataTransfer.files[0]); }); }
        function escape(s) { return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); }
    </script>
</body>
</html>
